/**
 * Genetic Algorithm Module for Monte Carlo Parameter Optimization
 * 
 * This module optimizes beta coefficients and mean reversion parameters
 * to maximize prediction accuracy against historical data.
 * 
 * Usage:
 *   const optimizer = new GeneticOptimizer(mcModel, historicalData);
 *   const result = await optimizer.optimize(baseInputs, {
 *     generations: 50,
 *     populationSize: 100,
 *     eliteRatio: 0.2,
 *     mutationRate: 0.15
 *   });
 */

class GeneticOptimizer {
  constructor(mcModel, historicalData) {
    this.model = mcModel;
    this.historicalData = historicalData; // Array of actual returns
    this.config = {
      generations: 50,
      populationSize: 100,
      eliteRatio: 0.2,           // Top 20% survive
      mutationRate: 0.15,         // 15% mutation probability
      mutationStrength: 0.1,      // 10% variation in mutations
      crossoverRate: 0.8,         // 80% crossover probability
      validationSplit: 0.3        // 30% for validation
    };
    
    // Parameter bounds for safety
    this.bounds = {
      betaReal: [-1.5, 0.5],
      betaExpReal: [-1.5, 0.5],
      betaInfl: [-0.5, 0.8],
      betaVix: [0, 0.5],
      betaDxy: [-0.15, 0.15],
      betaCredit: [-0.3, 0.1],
      betaTerm: [-0.1, 0.3],
      meanReversion: [0, 0.5]
    };
  }

  /**
   * Main optimization loop
   */
  async optimize(baseInputs, userConfig = {}) {
    this.config = { ...this.config, ...userConfig };
    
    // Split data for validation
    const splitIdx = Math.floor(this.historicalData.length * (1 - this.config.validationSplit));
    const trainData = this.historicalData.slice(0, splitIdx);
    const validData = this.historicalData.slice(splitIdx);
    
    // Initialize population
    let population = this.initializePopulation(baseInputs);
    
    const results = {
      generations: [],
      bestIndividual: null,
      bestFitness: -Infinity,
      convergenceHistory: []
    };
    
    console.log(`ðŸ§¬ Starting GA: ${this.config.generations} generations, population ${this.config.populationSize}`);
    
    for (let gen = 0; gen < this.config.generations; gen++) {
      // Evaluate fitness for entire population
      const fitnesses = await this.evaluatePopulation(population, baseInputs, trainData);
      
      // Sort by fitness
      const ranked = population.map((ind, i) => ({
        individual: ind,
        fitness: fitnesses[i]
      })).sort((a, b) => b.fitness - a.fitness);
      
      // Track best
      if (ranked[0].fitness > results.bestFitness) {
        results.bestFitness = ranked[0].fitness;
        results.bestIndividual = { ...ranked[0].individual };
      }
      
      // Validate on holdout
      const validFitness = await this.validateIndividual(
        ranked[0].individual, 
        baseInputs, 
        validData
      );
      
      results.convergenceHistory.push({
        generation: gen,
        bestTrainFitness: ranked[0].fitness,
        bestValidFitness: validFitness,
        avgFitness: fitnesses.reduce((a, b) => a + b, 0) / fitnesses.length,
        diversity: this.calculateDiversity(population)
      });
      
      // Log progress
      if (gen % 10 === 0 || gen === this.config.generations - 1) {
        console.log(
          `Gen ${gen}: Best=${ranked[0].fitness.toFixed(4)}, ` +
          `Valid=${validFitness.toFixed(4)}, ` +
          `Avg=${results.convergenceHistory[gen].avgFitness.toFixed(4)}, ` +
          `Diversity=${results.convergenceHistory[gen].diversity.toFixed(3)}`
        );
      }
      
      // Early stopping if converged
      if (gen > 20 && this.hasConverged(results.convergenceHistory, 10)) {
        console.log(`âœ… Converged at generation ${gen}`);
        break;
      }
      
      // Create next generation
      population = this.evolve(ranked);
    }
    
    // Final validation
    const finalValidation = await this.validateIndividual(
      results.bestIndividual,
      baseInputs,
      validData
    );
    
    results.finalValidationScore = finalValidation;
    results.improvement = this.calculateImprovement(baseInputs, results.bestIndividual);
    
    return results;
  }

  /**
   * Initialize random population around base parameters
   */
  initializePopulation(baseInputs) {
    const population = [];
    
    for (let i = 0; i < this.config.populationSize; i++) {
      const individual = {
        betaReal: this.randomInBounds('betaReal', baseInputs.betas.real),
        betaExpReal: this.randomInBounds('betaExpReal', baseInputs.betas.expReal),
        betaInfl: this.randomInBounds('betaInfl', baseInputs.betas.infl),
        betaVix: this.randomInBounds('betaVix', baseInputs.betas.vix),
        betaDxy: this.randomInBounds('betaDxy', baseInputs.betas.dxy),
        betaCredit: this.randomInBounds('betaCredit', baseInputs.betas.credit),
        betaTerm: this.randomInBounds('betaTerm', baseInputs.betas.term),
        meanReversion: this.randomInBounds('meanReversion', baseInputs.meanReversion)
      };
      population.push(individual);
    }
    
    return population;
  }

  /**
   * Random value within bounds, centered around base
   */
  randomInBounds(param, base) {
    const [min, max] = this.bounds[param];
    const range = max - min;
    const variation = range * 0.3; // 30% of range
    let value = base + (Math.random() - 0.5) * variation;
    return Math.max(min, Math.min(max, value));
  }

  /**
   * Evaluate fitness of entire population
   */
  async evaluatePopulation(population, baseInputs, trainData) {
    const fitnesses = [];
    
    for (const individual of population) {
      const fitness = await this.evaluateFitness(individual, baseInputs, trainData);
      fitnesses.push(fitness);
    }
    
    return fitnesses;
  }

  /**
   * Fitness function: How well do predictions match actual returns?
   */
  async evaluateFitness(individual, baseInputs, trainData) {
    try {
      // Create inputs with this individual's parameters
      const testInputs = {
        ...baseInputs,
        betas: {
          real: individual.betaReal,
          expReal: individual.betaExpReal,
          infl: individual.betaInfl,
          vix: individual.betaVix,
          dxy: individual.betaDxy,
          credit: individual.betaCredit,
          term: individual.betaTerm
        },
        meanReversion: individual.meanReversion,
        iters: 500 // Lower for speed during optimization
      };
      
      // Run Monte Carlo with these parameters
      const { stats } = this.model.run(testInputs);
      
      // Calculate prediction error vs historical mean
      const historicalMean = trainData.reduce((a, b) => a + b, 0) / trainData.length;
      const historicalStd = Math.sqrt(
        trainData.reduce((sum, x) => sum + Math.pow(x - historicalMean, 2), 0) / trainData.length
      );
      
      // Multi-objective fitness:
      // 1. How close is predicted mean to historical mean?
      const meanError = Math.abs(stats.mean - historicalMean) / Math.max(0.1, historicalStd);
      
      // 2. How close is predicted std to historical std?
      const stdError = Math.abs(stats.stdDev - historicalStd) / Math.max(0.1, historicalStd);
      
      // 3. Does it predict reasonable Sharpe ratio?
      const sharpeScore = Math.max(0, Math.min(3, stats.mean / stats.stdDev));
      
      // 4. Penalize extreme parameters (regularization)
      const regularization = this.calculateRegularization(individual);
      
      // Combined fitness (higher is better)
      const fitness = 
        -0.4 * meanError +           // Match mean
        -0.3 * stdError +             // Match volatility
        0.2 * sharpeScore +           // Reasonable risk-adjusted return
        -0.1 * regularization;        // Don't overfit
      
      return fitness;
      
    } catch (error) {
      // Penalize invalid parameter combinations
      return -1000;
    }
  }

  /**
   * Validate on holdout data
   */
  async validateIndividual(individual, baseInputs, validData) {
    return this.evaluateFitness(individual, baseInputs, validData);
  }

  /**
   * Regularization to prevent extreme parameters
   */
  calculateRegularization(individual) {
    let penalty = 0;
    
    for (const [key, value] of Object.entries(individual)) {
      const [min, max] = this.bounds[key];
      const range = max - min;
      const center = (max + min) / 2;
      const deviation = Math.abs(value - center) / (range / 2);
      penalty += deviation;
    }
    
    return penalty / Object.keys(individual).length;
  }

  /**
   * Calculate diversity of population (prevents premature convergence)
   */
  calculateDiversity(population) {
    let totalVariance = 0;
    const params = Object.keys(population[0]);
    
    for (const param of params) {
      const values = population.map(ind => ind[param]);
      const mean = values.reduce((a, b) => a + b, 0) / values.length;
      const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
      totalVariance += variance;
    }
    
    return Math.sqrt(totalVariance / params.length);
  }

  /**
   * Check if GA has converged
   */
  hasConverged(history, window) {
    if (history.length < window) return false;
    
    const recent = history.slice(-window);
    const fitnessValues = recent.map(h => h.bestTrainFitness);
    const improvement = fitnessValues[fitnessValues.length - 1] - fitnessValues[0];
    
    // Converged if improvement < 0.1% over last window generations
    return improvement < 0.001;
  }

  /**
   * Create next generation through selection, crossover, mutation
   */
  evolve(rankedPopulation) {
    const newPopulation = [];
    const eliteCount = Math.floor(this.config.populationSize * this.config.eliteRatio);
    
    // Elitism: Keep best individuals
    for (let i = 0; i < eliteCount; i++) {
      newPopulation.push({ ...rankedPopulation[i].individual });
    }
    
    // Fill rest through crossover and mutation
    while (newPopulation.length < this.config.populationSize) {
      // Tournament selection
      const parent1 = this.tournamentSelect(rankedPopulation);
      const parent2 = this.tournamentSelect(rankedPopulation);
      
      // Crossover
      let child;
      if (Math.random() < this.config.crossoverRate) {
        child = this.crossover(parent1, parent2);
      } else {
        child = Math.random() < 0.5 ? { ...parent1 } : { ...parent2 };
      }
      
      // Mutation
      child = this.mutate(child);
      
      newPopulation.push(child);
    }
    
    return newPopulation;
  }

  /**
   * Tournament selection: Pick best of random subset
   */
  tournamentSelect(ranked, tournamentSize = 5) {
    const tournament = [];
    for (let i = 0; i < tournamentSize; i++) {
      const idx = Math.floor(Math.random() * ranked.length);
      tournament.push(ranked[idx]);
    }
    tournament.sort((a, b) => b.fitness - a.fitness);
    return tournament[0].individual;
  }

  /**
   * Uniform crossover: Randomly mix parent genes
   */
  crossover(parent1, parent2) {
    const child = {};
    for (const key of Object.keys(parent1)) {
      child[key] = Math.random() < 0.5 ? parent1[key] : parent2[key];
    }
    return child;
  }

  /**
   * Mutation: Small random changes
   */
  mutate(individual) {
    const mutated = { ...individual };
    
    for (const key of Object.keys(mutated)) {
      if (Math.random() < this.config.mutationRate) {
        const [min, max] = this.bounds[key];
        const range = max - min;
        const change = (Math.random() - 0.5) * range * this.config.mutationStrength;
        mutated[key] = Math.max(min, Math.min(max, mutated[key] + change));
      }
    }
    
    return mutated;
  }

  /**
   * Calculate improvement over baseline
   */
  calculateImprovement(baseInputs, bestIndividual) {
    const improvements = {};
    
    improvements.betaReal = ((bestIndividual.betaReal - baseInputs.betas.real) / Math.abs(baseInputs.betas.real) * 100).toFixed(1);
    improvements.betaExpReal = ((bestIndividual.betaExpReal - baseInputs.betas.expReal) / Math.abs(baseInputs.betas.expReal) * 100).toFixed(1);
    improvements.betaInfl = ((bestIndividual.betaInfl - baseInputs.betas.infl) / Math.abs(baseInputs.betas.infl) * 100).toFixed(1);
    improvements.meanReversion = ((bestIndividual.meanReversion - baseInputs.meanReversion) / Math.abs(baseInputs.meanReversion) * 100).toFixed(1);
    
    return improvements;
  }

  /**
   * Export results for integration
   */
  exportResults(results) {
    return {
      optimizedBetas: {
        real: results.bestIndividual.betaReal,
        expReal: results.bestIndividual.betaExpReal,
        infl: results.bestIndividual.betaInfl,
        vix: results.bestIndividual.betaVix,
        dxy: results.bestIndividual.betaDxy,
        credit: results.bestIndividual.betaCredit,
        term: results.bestIndividual.betaTerm
      },
      optimizedMeanReversion: results.bestIndividual.meanReversion,
      trainingScore: results.bestFitness,
      validationScore: results.finalValidationScore,
      improvement: results.improvement,
      convergedAt: results.convergenceHistory.length,
      diagnostics: {
        finalDiversity: results.convergenceHistory[results.convergenceHistory.length - 1]?.diversity,
        fitnessProgress: results.convergenceHistory.map(h => ({
          gen: h.generation,
          train: h.bestTrainFitness,
          valid: h.bestValidFitness
        }))
      }
    };
  }
}

// ============================================================================
// EXAMPLE USAGE
// ============================================================================

/*
// In your main app:

// 1. Initialize with your MC model and historical data
const historicalReturns = [10.3, -5.2, 18.7, 6.1, 12.2, 4.0, -8.1, 22.4, 9.9, 3.6, 15.2, -2.8, 11.5, 7.3, 13.8];
const optimizer = new GeneticOptimizer(mcModel, historicalReturns);

// 2. Run optimization
const baseInputs = getCurrentInputs(); // Your existing function
const results = await optimizer.optimize(baseInputs, {
  generations: 50,
  populationSize: 100,
  mutationRate: 0.15
});

// 3. Extract optimized parameters
const optimized = optimizer.exportResults(results);
console.log('Optimized betas:', optimized.optimizedBetas);
console.log('Validation score:', optimized.validationScore);
console.log('Improvement:', optimized.improvement);

// 4. Update UI with new parameters
document.getElementById('betaReal').value = optimized.optimizedBetas.real.toFixed(3);
document.getElementById('betaExpReal').value = optimized.optimizedBetas.expReal.toFixed(3);
// ... etc

// 5. Show convergence chart (optional)
plotConvergence(optimized.diagnostics.fitnessProgress);
*/

// Export for use in browser or Node.js
if (typeof module !== 'undefined' && module.exports) {
  module.exports = GeneticOptimizer;
}
